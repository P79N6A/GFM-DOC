(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{372:function(e,t,o){"use strict";o.r(t);var i=o(46),n=Object(i.a)({},function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h3",{attrs:{id:"inline-structure"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#inline-structure","aria-hidden":"true"}},[e._v("#")]),e._v(" inline structure")]),e._v(" "),o("p",[e._v("Once all of the input has been parsed, all open blocks are closed."),o("br"),e._v("\nWe then “walk the tree,” visiting every node, and parse raw string contents of paragraphs and headings as inlines. At this point we have seen all the link reference definitions, so we can resolve reference links as we go.")]),e._v(" "),o("pre",[o("code",[e._v('document\n  block_quote\n    paragraph\n      str "Lorem ipsum dolor"\n      softbreak\n      str "sit amet."\n    list (type=bullet tight=true bullet_char=-)\n      list_item\n        paragraph\n          str "Qui "\n          emph\n            str "quodsi iracundia"\n      list_item\n        paragraph\n          str "aliquando id"\n')])]),e._v(" "),o("p",[e._v("Notice how the "),o("a",{attrs:{href:"https://github.github.com/gfm/#line-ending",target:"_blank",rel:"noopener noreferrer"}},[e._v("line ending"),o("OutboundLink")],1),e._v(" in the first paragraph has been parsed as a "),o("code",[e._v("softbreak")]),e._v(", and the asterisks in the first list item have become an "),o("code",[e._v("emph")]),e._v("."),o("br"),e._v("\nAn algorithm for parsing nested emphasis and linksBy far the trickiest part of inline parsing is handling emphasis, strong emphasis, links, and images. This is done using the following algorithm."),o("br"),e._v("\nWhen we’re parsing inlines and we hit either")]),e._v(" "),o("ul",[o("li",[e._v("a run of "),o("code",[e._v("*")]),e._v(" or "),o("code",[e._v("_")]),e._v(" characters, or")]),e._v(" "),o("li",[e._v("a "),o("code",[e._v("[")]),e._v(" or "),o("code",[e._v("![")])])]),e._v(" "),o("p",[e._v("we insert a text node with these symbols as its literal content, and we add a pointer to this text node to the "),o("a",{attrs:{href:"https://github.github.com/gfm/#delimiter-stack",target:"_blank",rel:"noopener noreferrer"}},[e._v("delimiter stack"),o("OutboundLink")],1),e._v("."),o("br"),e._v("\nThe "),o("a",{attrs:{href:"https://github.github.com/gfm/#delimiter-stack",target:"_blank",rel:"noopener noreferrer"}},[e._v("delimiter stack"),o("OutboundLink")],1),e._v(" is a doubly linked list. Each element contains a pointer to a text node, plus information about")]),e._v(" "),o("ul",[o("li",[e._v("the type of delimiter ("),o("code",[e._v("[")]),e._v(", "),o("code",[e._v("![")]),e._v(", "),o("code",[e._v("*")]),e._v(", "),o("code",[e._v("_")]),e._v(")")]),e._v(" "),o("li",[e._v("the number of delimiters,")]),e._v(" "),o("li",[e._v("whether the delimiter is “active” (all are active to start), and")]),e._v(" "),o("li",[e._v("whether the delimiter is a potential opener, a potential closer, or both (which depends on what sort of characters precede and follow the delimiters).")])]),e._v(" "),o("p",[e._v("When we hit a "),o("code",[e._v("]")]),e._v(" character, we call the "),o("em",[e._v("look for link or image")]),e._v(" procedure (see below)."),o("br"),e._v("\nWhen we hit the end of the input, we call the "),o("em",[e._v("process emphasis")]),e._v(" procedure (see below), with "),o("code",[e._v("stack_bottom")]),e._v("= NULL."),o("br"),e._v("\n_look for link or image_Starting at the top of the delimiter stack, we look backwards through the stack for an opening "),o("code",[e._v("[")]),e._v(" or "),o("code",[e._v("![")]),e._v("delimiter.")]),e._v(" "),o("ul",[o("li",[e._v("If we don’t find one, we return a literal text node "),o("code",[e._v("]")]),e._v(".")]),e._v(" "),o("li",[e._v("If we do find one, but it’s not "),o("em",[e._v("active")]),e._v(", we remove the inactive delimiter from the stack, and return a literal text node "),o("code",[e._v("]")]),e._v(".")]),e._v(" "),o("li",[e._v("If we find one and it’s active, then we parse ahead to see if we have an inline link/image, reference link/image, compact reference link/image, or shortcut reference link/image.\n"),o("ul",[o("li",[e._v("If we don’t, then we remove the opening delimiter from the delimiter stack and return a literal text node "),o("code",[e._v("]")]),e._v(".")]),e._v(" "),o("li",[e._v("If we do, then\n"),o("ul",[o("li",[e._v("We return a link or image node whose children are the inlines after the text node pointed to by the opening delimiter.")]),e._v(" "),o("li",[e._v("We run "),o("em",[e._v("process emphasis")]),e._v(" on these inlines, with the "),o("code",[e._v("[")]),e._v(" opener as "),o("code",[e._v("stack_bottom")]),e._v(".")]),e._v(" "),o("li",[e._v("We remove the opening delimiter.")]),e._v(" "),o("li",[e._v("If we have a link (and not an image), we also set all "),o("code",[e._v("[")]),e._v(" delimiters before the opening delimiter to "),o("em",[e._v("inactive")]),e._v(". (This will prevent us from getting links within links.)")])])])])])]),e._v(" "),o("p",[e._v("_process emphasis_Parameter "),o("code",[e._v("stack_bottom")]),e._v(" sets a lower bound to how far we descend in the "),o("a",{attrs:{href:"https://github.github.com/gfm/#delimiter-stack",target:"_blank",rel:"noopener noreferrer"}},[e._v("delimiter stack"),o("OutboundLink")],1),e._v(". If it is NULL, we can go all the way to the bottom. Otherwise, we stop before visiting "),o("code",[e._v("stack_bottom")]),e._v("."),o("br"),e._v("\nLet "),o("code",[e._v("current_position")]),e._v(" point to the element on the "),o("a",{attrs:{href:"https://github.github.com/gfm/#delimiter-stack",target:"_blank",rel:"noopener noreferrer"}},[e._v("delimiter stack"),o("OutboundLink")],1),e._v(" just above "),o("code",[e._v("stack_bottom")]),e._v(" (or the first element if "),o("code",[e._v("stack_bottom")]),e._v(" is NULL)."),o("br"),e._v("\nWe keep track of the "),o("code",[e._v("openers_bottom")]),e._v(" for each delimiter type ("),o("code",[e._v("*")]),e._v(", "),o("code",[e._v("_")]),e._v("). Initialize this to "),o("code",[e._v("stack_bottom")]),e._v("."),o("br"),e._v("\nThen we repeat the following until we run out of potential closers:")]),e._v(" "),o("ul",[o("li",[e._v("Move "),o("code",[e._v("current_position")]),e._v(" forward in the delimiter stack (if needed) until we find the first potential closer with delimiter "),o("code",[e._v("*")]),e._v(" or "),o("code",[e._v("_")]),e._v(". (This will be the potential closer closest to the beginning of the input – the first one in parse order.)")]),e._v(" "),o("li",[e._v("Now, look back in the stack (staying above "),o("code",[e._v("stack_bottom")]),e._v(" and the "),o("code",[e._v("openers_bottom")]),e._v(" for this delimiter type) for the first matching potential opener (“matching” means same delimiter).")]),e._v(" "),o("li",[e._v("If one is found:\n"),o("ul",[o("li",[e._v("Figure out whether we have emphasis or strong emphasis: if both closer and opener spans have length >= 2, we have strong, otherwise regular.")]),e._v(" "),o("li",[e._v("Insert an emph or strong emph node accordingly, after the text node corresponding to the opener.")]),e._v(" "),o("li",[e._v("Remove any delimiters between the opener and closer from the delimiter stack.")]),e._v(" "),o("li",[e._v("Remove 1 (for regular emph) or 2 (for strong emph) delimiters from the opening and closing text nodes. If they become empty as a result, remove them and remove the corresponding element of the delimiter stack. If the closing node is removed, reset "),o("code",[e._v("current_position")]),e._v(" to the next element in the stack.")])])]),e._v(" "),o("li",[e._v("If none in found:\n"),o("ul",[o("li",[e._v("Set "),o("code",[e._v("openers_bottom")]),e._v(" to the element before "),o("code",[e._v("current_position")]),e._v(". (We know that there are no openers for this kind of closer up to and including this point, so this puts a lower bound on future searches.)")]),e._v(" "),o("li",[e._v("If the closer at "),o("code",[e._v("current_position")]),e._v(" is not a potential opener, remove it from the delimiter stack (since we know it can’t be a closer either).")]),e._v(" "),o("li",[e._v("Advance "),o("code",[e._v("current_position")]),e._v(" to the next element in the stack.")])])])]),e._v(" "),o("p",[e._v("After we’re done, we remove all delimiters above "),o("code",[e._v("stack_bottom")]),e._v(" from the delimiter stack.")])])},[],!1,null,null,null);t.default=n.exports}}]);